# 문자열 마음대로 정렬하기

[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/12915)

## 문제

문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 ["sun", "bed", "car"]이고 n이 1이면 각 단어의 인덱스 1의 문자 "u", "e", "a"로 strings를 정렬합니다.

## 제한 조건

- strings는 길이 1 이상, 50이하인 배열입니다.
- strings의 원소는 소문자 알파벳으로 이루어져 있습니다.
- strings의 원소는 길이 1 이상, 100이하인 문자열입니다.
- 모든 strings의 원소의 길이는 n보다 큽니다.
- 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.

## 첫 번째 제출 코드

```javascript
const solution = (strings, n) =>
  strings.sort().sort((a, b) => a[n].charCodeAt(0) - b[n].charCodeAt(0));
```

## 풀이 과정

1. `strings`의 `sort()` 메소드를 활용하여 전체 문자열을 기준으로 오름차순으로 정렬한다.
2. `sort()` 메소드의 콜백 함수로 문제에서 요구하는 정렬을 한다.
   - 문자열의 `n`번째 문자의 UTF 코드를 비교한다.
   - `a` 문자 코드에서 `b` 문자 코드를 뺀다.
   - `b` 코드가 `a`보다 나중에 위치할 때 음수값이 나올 것이므로 오름차순 정렬이 된다.
3. 메소드 체이닝의 결과를 반환한다.

### 문제점

- `n`번째 문자가 같은 경우를 처리하기 위해 정렬을 두 번 하는 것이 마음에 걸렸다. `sort()` 메소드의 콜백 함수를 수정해서 모든 경우를 처리할 수 있을 것 같다.

## 두 번째 제출 코드

```javascript
const solution = (strings, n) =>
  strings.sort((a, b) =>
    a[n] === b[n] ? a.localeCompare(b) : a[n].charCodeAt(0) - b[n].charCodeAt(0)
  );
```

### 풀이 과정

1. `strings`에 `sort()` 메소드를 적용하여 정렬하다.
2. 만약 `a`와 `b`의 `n`번째 문자가 같다면 `b`에 대한 `a`의 상대적 위치를 구한다.
3. 아니라면 `n`번째 문자의 코드를 서로 비교하여 정렬한다.

### 문제점

- 정렬 과정을 한 번으로 통일했음에도 불구하고 오히려 실행 속도가 엄청나게 느려졌다.
- 첫 번째 코드에서 `n`번째 문자 비교 부분을 `localeCompare`로 바꿨을 경우에도 실행 속도가 느려지는 것으로 보아, `localeCompare` 메소드의 성능이 느린 것으로 보인다.
